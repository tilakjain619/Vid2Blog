import { TranscriptService } from '../transcript-service';
import { YoutubeTranscript } from 'youtube-transcript';

// Mock the youtube-transcript module
jest.mock('youtube-transcript');
const mockYoutubeTranscript = YoutubeTranscript as jest.Mocked<typeof YoutubeTranscript>;

describe('TranscriptService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('extractTranscript', () => {
    it('should extract transcript successfully', async () => {
      const mockTranscriptData = [
        { text: 'Hello world', offset: 0, duration: 2000 },
        { text: 'This is a test', offset: 2000, duration: 3000 },
        { text: 'End of transcript', offset: 5000, duration: 2000 }
      ];

      mockYoutubeTranscript.fetchTranscript.mockResolvedValue(mockTranscriptData);

      const result = await TranscriptService.extractTranscript('test-video-id');

      expect(result).toEqual({
        segments: [
          {
            text: 'Hello world',
            startTime: 0,
            endTime: 2,
            confidence: 1.0
          },
          {
            text: 'This is a test',
            startTime: 2,
            endTime: 5,
            confidence: 1.0
          },
          {
            text: 'End of transcript',
            startTime: 5,
            endTime: 7,
            confidence: 1.0
          }
        ],
        language: 'en',
        confidence: 1.0,
        duration: 7
      });

      expect(mockYoutubeTranscript.fetchTranscript).toHaveBeenCalledWith('test-video-id', {
        lang: 'en',
        country: 'US'
      });
    });

    it('should handle custom language and country options', async () => {
      const mockTranscriptData = [
        { text: 'Hola mundo', offset: 0, duration: 2000 }
      ];

      mockYoutubeTranscript.fetchTranscript.mockResolvedValue(mockTranscriptData);

      const result = await TranscriptService.extractTranscript('test-video-id', {
        lang: 'es',
        country: 'ES'
      });

      expect(result.language).toBe('es');
      expect(mockYoutubeTranscript.fetchTranscript).toHaveBeenCalledWith('test-video-id', {
        lang: 'es',
        country: 'ES'
      });
    });

    it('should handle empty transcript data', async () => {
      mockYoutubeTranscript.fetchTranscript.mockResolvedValue([]);

      const result = await TranscriptService.extractTranscript('test-video-id');

      expect(result).toEqual({
        segments: [],
        language: 'en',
        confidence: 1.0,
        duration: 0
      });
    });

    it('should throw error when transcript extraction fails', async () => {
      mockYoutubeTranscript.fetchTranscript.mockRejectedValue(new Error('Transcript not available'));

      await expect(TranscriptService.extractTranscript('test-video-id'))
        .rejects.toThrow('Failed to extract transcript: Transcript not available');
    });

    it('should handle unknown errors', async () => {
      mockYoutubeTranscript.fetchTranscript.mockRejectedValue('Unknown error');

      await expect(TranscriptService.extractTranscript('test-video-id'))
        .rejects.toThrow('Failed to extract transcript: Unknown error');
    });
  });

  describe('getAvailableCaptions', () => {
    it('should return available captions for multiple languages', async () => {
      // Mock successful calls for English and Spanish
      mockYoutubeTranscript.fetchTranscript
        .mockResolvedValueOnce([{ text: 'English', offset: 0, duration: 1000 }])
        .mockRejectedValueOnce(new Error('Not available'))
        .mockRejectedValueOnce(new Error('Not available'))
        .mockRejectedValueOnce(new Error('Not available'))
        .mockRejectedValueOnce(new Error('Not available'))
        .mockRejectedValueOnce(new Error('Not available'))
        .mockRejectedValueOnce(new Error('Not available'))
        .mockRejectedValueOnce(new Error('Not available'))
        .mockRejectedValueOnce(new Error('Not available'))
        .mockResolvedValueOnce([{ text: 'Chinese', offset: 0, duration: 1000 }]);

      const result = await TranscriptService.getAvailableCaptions('test-video-id');

      expect(result).toEqual([
        {
          languageCode: 'en',
          languageName: 'English',
          isAutoGenerated: true
        },
        {
          languageCode: 'zh',
          languageName: 'Chinese',
          isAutoGenerated: true
        }
      ]);
    });

    it('should return empty array when no captions are available', async () => {
      mockYoutubeTranscript.fetchTranscript.mockRejectedValue(new Error('Not available'));

      const result = await TranscriptService.getAvailableCaptions('test-video-id');

      expect(result).toEqual([]);
    });
  });

  describe('isTranscriptAvailable', () => {
    it('should return true when transcript is available', async () => {
      mockYoutubeTranscript.fetchTranscript.mockResolvedValue([
        { text: 'Available', offset: 0, duration: 1000 }
      ]);

      const result = await TranscriptService.isTranscriptAvailable('test-video-id');

      expect(result).toBe(true);
      expect(mockYoutubeTranscript.fetchTranscript).toHaveBeenCalledWith('test-video-id', {
        lang: 'en'
      });
    });

    it('should return false when transcript is not available', async () => {
      mockYoutubeTranscript.fetchTranscript.mockRejectedValue(new Error('Not available'));

      const result = await TranscriptService.isTranscriptAvailable('test-video-id');

      expect(result).toBe(false);
    });

    it('should check specific language availability', async () => {
      mockYoutubeTranscript.fetchTranscript.mockResolvedValue([
        { text: 'Disponible', offset: 0, duration: 1000 }
      ]);

      const result = await TranscriptService.isTranscriptAvailable('test-video-id', 'es');

      expect(result).toBe(true);
      expect(mockYoutubeTranscript.fetchTranscript).toHaveBeenCalledWith('test-video-id', {
        lang: 'es'
      });
    });
  });
});